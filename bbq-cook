#!/opt/local/bin/ruby

#
# bbq-cook - generates a binary blob from a .di file
#
#  usage:
#      bbq-cook input.di output.bin
#

require 'bbq'
require 'optparse'

# parse cmdline args
options = {}
opts = OptionParser.new do |opts|
  opts.banner = "bbq-cook : Generate a binary file from a di file.\n\tUsage: bbq-cook [options] di_file bin_file"

  opts.on('-h', '--help', 'Display this screen') do
    puts opts
    exit
  end
end
opts.parse!(ARGV)

if ARGV.size != 2
  puts opts
  exit
end

di_file, bin_file = ARGV

# look up CStruct name
module BBQ
  def self.const_missing name
    result = $type_registry[name]
    if result
      result
    else
      super name
    end      
  end
end

puts "loading #{di_file}"
load di_file
puts "finished loading #{di_file}"

if BBQ.data_root.nil?
  raise "Missing BBQ.data in #{di_file}"
end

# see bbq.cpp for pointer table memory layout
class PointerTable
  def initialize
    @ptrs = []
  end

  def << offset
    @ptrs << offset
  end

  def str
    chunk = Chunk.new
    Uint32Type.cook chunk, @ptrs.size
    @ptrs.each do |ptr|
      Uint32Type.cook chunk, ptr
    end
    Uint32Type.cook chunk, @ptrs.size  # output num_pointers again
    chunk.str
  end
end


File.open(ARGV[1], "w") do |f|
  chunk = Chunk.new
  $type_registry[BBQ.data_root.type_name].cook(chunk, BBQ.data_root)
  chunk.resolve_pointers

  # fill up the pointer table
  pointer_table = PointerTable.new
  chunk.pointers.each do |ptr|
    pointer_table << ptr.src_offset
  end

  # output pointer table
  f.print pointer_table.str

  # output main chunk
  f.print chunk.str
end

